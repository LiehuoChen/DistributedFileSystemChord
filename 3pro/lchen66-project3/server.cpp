// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "FileStore.h"
#include "chord_join_remove_dht_types.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <transport/TSocket.h>
#include <transport/TBufferTransports.h>
#include <protocol/TBinaryProtocol.h>
#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>
#include <algorithm>
#include <fstream>
#include <sstream>
#include "sha256.h"


using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;
using std::string;
using std::cout;
using std::cerr;
using std::endl;
using std::unordered_map;
using std::ifstream;
using std::ofstream;
using std::vector;
using std::fill_n;
using std::ostringstream;

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/ioctl.h>
#include <net/if.h>
#include <arpa/inet.h>
#include <ifaddrs.h>

#define DECTOHEX(a) ((a) >= 10? (a) - 10 + 'a': (a) + '0');
#define HEXTODEC(a) ((a) >= 'a'? (a) - 'a' + 10 : (a) - '0')
#define JOIN 1
#define REMOVE 0
int global_port = 9090;
NodeID current;
NodeID successor;
NodeID predessor;
vector<NodeID> ftable;

/**
 * get the ip address for the running server.
 */
string get_eth_ip(void)
{
	struct ifaddrs *addrs, *tmp;
	getifaddrs(&addrs);
	tmp = addrs;
	char host[NI_MAXHOST];

	while (tmp) {
		if (tmp->ifa_addr 
				&& !strncmp(tmp->ifa_name, "eth", 3)  
				&& tmp->ifa_addr->sa_family == AF_INET)
			getnameinfo(tmp->ifa_addr, sizeof(struct sockaddr_in),
					host, NI_MAXHOST, NULL, 0, NI_NUMERICHOST);
		tmp = tmp->ifa_next;
	}

	freeifaddrs(addrs);
	return host;
}

bool keyCompare(const std::string &left,
		const std::string &middle,
		const std::string &right)
{
	return right > left ? (middle > left && middle < right)
		: ((middle > left && middle > right) ||
				(middle < left && middle < right));
}

void init_table()
{
	// set the NodeId itself when server starts
	current.__set_ip(get_eth_ip());
	cout << "current ip is " << get_eth_ip() << endl;
	current.__set_port(global_port);
	current.__set_id(sha256_ip_port_hex(current.ip, current.port));

	/********
	 * a new DHT node is started, it initializes itself, initializes its
	 * own fingertable as if it is the only node in the DHT when started by
	 *  seting  all its 256 fingertable entries to the node itself.
	 *******/
	//fill_n(ftable.begin(), ftable.end(), current);
	ftable.assign(256, current);
	predessor = current;
	successor = current;
}

class FileStoreHandler : virtual public FileStoreIf {
	public:
		typedef unordered_map<string, RFile> FilenameToRfile;
		FileStoreHandler() :userFiles() {}

		void writeFile(const RFile& rFile) {
			SystemException writeException;
			RFile lrfile = rFile;
			lrfile.__set_content(rFile.content);
			if (!checkRoute(rFile.meta.owner, rFile.meta.filename)) {
				writeException.__set_message("Errors! the file to be written is out of my range");
				throw writeException;
			}
			RFileMetadata fMeta = rFile.meta;
			char content_char[rFile.content.size()];
			string content = rFile.content;
			string user = rFile.meta.owner;
			string fileName = rFile.meta.filename;
			strcpy(content_char, rFile.content.c_str());

			if (!userFiles.count(user) )  /*if no user, create user */
				userFiles[user] = FilenameToRfile();

			FilenameToRfile &fMap = userFiles[user]; /*get the file list of user*/
			if (!fMap.count(fileName)) /*if new file, create it */
			{
				fMeta.__set_created((int64_t) time(0));
				fMeta.__set_updated((int64_t) time(0));
				fMeta.__set_deleted(0);
				fMeta.__set_version(0);
				fMeta.__set_contentLength(rFile.content.size());
				fMeta.__set_contentHash(sha256_calc_hex(content_char));
				lrfile.__set_meta(fMeta);
				fMap[fileName] = lrfile;
			} else { // update a file when writeing file existed
				// get the meta info of old file
				RFileMetadata fMetaPre = fMap[fileName].meta;
				fMetaPre.__set_version(fMetaPre.version + 1);
				fMetaPre.__set_updated((int64_t) time(0));
				fMetaPre.__set_deleted(0);
				fMetaPre.__set_contentHash(sha256_calc_hex(content_char));
				fMetaPre.__set_contentLength(rFile.content.size());
				lrfile.__set_meta(fMetaPre);
				fMap[fileName] = lrfile;
			}
			cout << "writeFile success" << endl;
		}

		void readFile(RFile& _return, const std::string& filename, const UserID& owner) {
			SystemException readExcep;
			RFile lrfile;
			if (!checkRoute(owner, filename)) {
				readExcep.__set_message("Errors! the file to be written is out of my range");
				throw readExcep;
			}

			if (!userFiles.count(owner)) {
				readExcep.__set_message("readFile Failed! throw exception because of"
						" user not existed!");
				throw readExcep; 
			}

			FilenameToRfile &fMap = userFiles[owner];
			if (!fMap.count(filename) || fMap[filename].meta.deleted) {
				cerr << "File not existed or deleted!, owner is "
					<< owner << " file name is " << filename << endl;
				readExcep.__set_message("deleteFile Failed, throw exception because"
						" of file not existed or deleted while deleting");
				throw readExcep;
			}

			if (!fMap.count(filename)) {
				readExcep.__set_message("readFile Failed! throw exception because of " 
						"filename not existed!");
				throw readExcep; 
			}
			_return.__set_meta(fMap[filename].meta);
			_return.__set_content(fMap[filename].content);
			cout << "readFile success! " << endl;
		}

		void deleteFile(const std::string& filename, const UserID& owner) {
			// Your implementation goes here
			SystemException deleteExcep;
			if (!checkRoute(owner, filename)) {
				deleteExcep.__set_message("file not belong to my range");
				throw deleteExcep;
			}

			if (!userFiles.count(owner))
			{
				cerr << "deleteFile Failed! user not existed! owner is" << owner
					<< "file name is " << filename << endl;
				deleteExcep.__set_message("deleteFile Failed!, throw exeception "
						" because of user not existed while deleting file");
				throw deleteExcep;
			}

			FilenameToRfile &fMap = userFiles[owner]; /*get the file list of user*/
			if (!fMap.count(filename) || fMap[filename].meta.deleted)
			{
				cerr << "deleteFile Failed!, file not existed or deleted!, owner is "
					<< owner << " file name is " << filename;
				deleteExcep.__set_message("deleteFile Failed, throw exception because"
						" of file not existed or deleted while deleting");
				throw deleteExcep;
			}
			fMap[filename].meta.__set_deleted((int64_t) time(0));
			cout << "deleteFile success! " << endl;
			return;
		}

		void setFingertable(const std::vector<NodeID> & node_list) {
			// Your implementation goes here
			ftable = node_list;
			successor = ftable[0];
			cout << "setFingertable Finished! " << endl;
			//	dhtSetFingertable(node_list);
		}

		void findSucc(NodeID& _return, const std::string& key) {
			// Your implementation goes here
			cout << "findSucc key: " <<  key << endl;
			NodeID pred = dhtFindPred(key, __LINE__);
			cout << "findSucc pred: " << pred.ip << " : " << pred.port  << endl;
			if (pred.id == current.id) {
				_return = successor;
				return;
			}
			boost::shared_ptr<FileStoreClient> client(getClientConn(pred.ip, pred.port));
			if (!client.get()) {
				SystemException ConnExcep;
				cerr << "Connect to predessor Failed at " << pred.ip << ":" <<
					pred.port << endl;
				ConnExcep.__set_message("Error! Connect to predessor Failed!\n");
				throw ConnExcep;
			}
			NodeID result;
			client->getNodeSucc(result);
			_return = result;
			return;
		}

		void findPred(NodeID& _return, const std::string& key) {
			// Your implementation goes here
			_return = dhtFindPred(key, __LINE__);
			//cout << "findPred Finished! " << endl;
		}

		void getNodeSucc(NodeID& _return) {
			// Your implementation goes here
			_return = successor;
			cout << "getNodeSucc Finished! " << endl;
		}

		void setNodePred(const NodeID& nodeId) {
			// Your implementation goes here
			predessor = nodeId;
			cout << "setNodePred Finished! " << endl;
		}

		void updateFinger(const int32_t idx, const NodeID& nodeId) {
			// Your implementation goes here
			ftable[idx] = nodeId;
			if (0 == idx)
			{
				successor = ftable[0];
			}
			cout << "updateFinger Finished! " << endl;
		}

		void getFingertable(std::vector<NodeID> & _return) {
			// Your implementation goes here
			_return.assign(ftable.begin(), ftable.end());
			cout << "getFingertable Finished! " << endl;
		}

		void pullUnownedFiles(std::vector<RFile> & _return) {
			// Your implementation goes here
			for(auto itemUser : userFiles)
				for(auto itemRf : itemUser.second)
				{
					// if not belong to my range and add to the _return and erase it
					if (!checkRoute(itemRf.second.meta.owner, itemRf.second.meta.filename))
					{
						_return.push_back(itemRf.second);
						userFiles[itemRf.second.meta.owner].erase(itemRf.second.meta.filename);
					}
				}
			cout << "pullUnownedFiles Finished! " << endl;
		}

		void pushUnownedFiles(const std::vector<RFile> & files) {
			// Your implementation goes here
			for(auto item : files)
			{
				RFile localRFile = item;
				if (0 == userFiles.count(localRFile.meta.owner))
				{
					userFiles.insert(make_pair(localRFile.meta.owner, FilenameToRfile()));
				}
				FilenameToRfile &fRfile = userFiles[localRFile.meta.owner];
				fRfile[localRFile.meta.filename] = localRFile;
			}
			cout << "pushUnownedFiles Finished!" << endl;
		}

		void join(const NodeID& nodeId) {
			// Your implementation goes here
			if(successor != current)
			{
				cout << "the joining node, ip: " << nodeId.ip << " port: " <<
					nodeId.port << " is alreadly in the system" << endl;
				cout << "do nothing for this node joining" << endl;
				return;
			}
			boost::shared_ptr<FileStoreClient> client = boost::shared_ptr<FileStoreClient>();
			vector<RFile> unownedFiles;
			//step1 : Create a fingertable for the new node.
			create_finger_table(nodeId, ftable);
			//step2 : Update the fingertables of the nodes affected by the node.
			update_fingertables(JOIN);	
			//step3 : trannsfer the files that are owned by nodenew but held by the
			//successor to nodenew
			client = getClientConn(successor.ip, successor.port);
			client->setNodePred(current); // set the pre of succ to current
			client->pullUnownedFiles(unownedFiles);
			pushUnownedFiles(unownedFiles);
			cout << "Join Finished! " << endl;
		}

		void remove() {
			// Your implementation goes here
			cout << "Enter : " << __func__ << endl;
			// throw Systemexception if it is the only node
			if (current.id == successor.id) {
				SystemException removeExcep;
				removeExcep.__set_message("Error! throw exception because of removing the only node!");
				throw removeExcep;
			}
			boost::shared_ptr<FileStoreClient> client(getClientConn(successor.ip, successor.port));
			client->setNodePred(predessor);
			client = boost::shared_ptr<FileStoreClient>();
			//step 1: Update the finger tables of the nodes affected
			update_fingertables(REMOVE);	
			//step 2 : transfer the files owned by noderemove to its successor.
			// first get the files owned by the removed Node
			vector<RFile> myownedFiles;
			for(auto itemUser : userFiles)
				for(auto itemRf : itemUser.second)
				{
					myownedFiles.push_back(itemRf.second);
				}
			userFiles.clear();
			// then push his own file to his successor
			boost::shared_ptr<FileStoreClient>
				succ_client(getClientConn(successor.ip, successor.port));
			//	cout << " the successor port is " << successor.port << endl;
			succ_client->pushUnownedFiles(myownedFiles);
			init_table();
			cout << "remove Succuss! " << endl;
		}


	private:
		unordered_map<UserID, FilenameToRfile> userFiles;
		boost::shared_ptr<FileStoreClient> getClientConn(const std::string &ip, int port) const
		{
			boost::shared_ptr<TSocket> socket(new TSocket(ip.c_str(), port));
			boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
			boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
			boost::shared_ptr<FileStoreClient> client(new FileStoreClient(protocol));
			try {
				transport->open();
			} catch (...) {
				client = boost::shared_ptr<FileStoreClient>();
			}
			return client;
		}


		bool checkRoute(const std::string &owner, const std::string &filename) 
		{
			std::string key = sha256_filename_owner_hex(owner, filename);
			if (key == current.id)
				return true;
			return keyCompare(predessor.id, key, current.id);
		}

		NodeID dhtFindPred(const std::string &key, int lineno) const
		{

			if (keyCompare(current.id, key, successor.id)) {
				return current;
			}
			for(int i = 0; i <= 255; i++) {
				if (keyCompare(current.id, ftable[i].id, key)) {
					boost::shared_ptr<FileStoreClient> client(getClientConn(ftable[i].ip, ftable[i].port));

					NodeID rst;
					client->findPred(rst, key);
					return rst;
				}
			}
			return current;
		}

		void getFileList(vector<RFileMetadata> & _return, const UserID& owner)
		{
			const FilenameToRfile &fMap = userFiles[owner];
			_return.clear();
			for(auto &item : fMap)
			{
				if (0 == item.second.meta.deleted)
				{
					_return.push_back(item.second.meta);
				}
			}
		}

		std::string addId(const std::string &id, int exp)
		{
			char idstr[65];
			snprintf(idstr, 65, id.c_str());
			int carry = (1 << (exp % 4));
			for(int i = 256 / 4 - exp / 4 - 1; i >= 0; i--) {
				int k = HEXTODEC(idstr[i]);
				k += carry;
				carry = k / 16;
				idstr[i] = DECTOHEX(k % 16);
				if (carry == 0)
					break;
			}
			return idstr;
		}

		std::string subId(const std::string &id, int exp)
		{
			char idstr[65];
			snprintf(idstr, 65, id.c_str());
			int carry = (1 << (exp % 4));
			for(int i = 256 / 4 - exp / 4 - 1; i >= 0; i--) {
				int k = HEXTODEC(idstr[i]);
				k -= carry;
				carry = 0;
				if (k < 0) {
					carry = 1;
					k += 16;
				}
				idstr[i] = DECTOHEX(k);
				if (carry == 0)
					break;
			}
			return idstr;
		}

		void create_finger_table(const NodeID &node, vector<NodeID> &fingertable)
		{
			boost::shared_ptr<FileStoreClient> client(getClientConn(node.ip, node.port));
			for(int i = 0; i < 256; i++) {
				std::string indexFtable = addId(current.id, i);
				NodeID succNode;
				client->findSucc(succNode, indexFtable);
				if (keyCompare(indexFtable, current.id, succNode.id))
					succNode = current;
				ftable[i] = succNode;
			}
			client->findPred(predessor, current.id);
			client = boost::shared_ptr<FileStoreClient>();
			successor = ftable[0];
		}

		void update_fingertables(int type)
		{
			boost::shared_ptr<FileStoreClient> client = boost::shared_ptr<FileStoreClient>();
			for (int i = 0; i < 256; i++) {
				NodeID currentItem;
				NodeID curr = dhtFindPred(subId(current.id, i), __LINE__);
				for ( ;curr.id != current.id; curr = dhtFindPred(curr.id, __LINE__)) {
					std::vector<NodeID> cur_fingertable;

					bool flag = false;
					NodeID toUpdate;
					client = getClientConn(curr.ip, curr.port);
					client->getFingertable(cur_fingertable);

					currentItem = curr;
					switch ( type ){
						case 1: // update finger table after join
							if (keyCompare(curr.id, current.id, cur_fingertable[i].id)) {
								toUpdate = current;
								flag = true;
							}
							break;
						case 0: // update finger tables after remove
							if (cur_fingertable[i].id == current.id) {
								toUpdate = successor;
								flag = true;
							}
							break;
						default:
							break;
					}
					if ( flag )
					{
						client->updateFinger(i, toUpdate);
					} else
					{
						client = boost::shared_ptr<FileStoreClient>();
						break;
					}
					client = boost::shared_ptr<FileStoreClient>();
				}
			}
		}
};

int main(int argc, char **argv) {
	int port = 3030;
	if (argc > 1)
		port = atoi(argv[1]);

	global_port = port;
	init_table();
	shared_ptr<FileStoreHandler> handler(new FileStoreHandler());
	shared_ptr<TProcessor> processor(new FileStoreProcessor(handler));
	shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
	shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
	shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

	TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
	server.serve();
	return 0;
}

