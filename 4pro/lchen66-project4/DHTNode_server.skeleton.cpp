// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "DHTNode.h"
#include "stable_chord_types.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/PosixThreadFactory.h>
#include <thrift/server/TThreadedServer.h>
#include <transport/TSocket.h>
#include <protocol/TBinaryProtocol.h>
//#include "lock.h"
#include "common.h"
#include "sha256.h"
#include <string>
#include <vector>
#include <ctime>
#include <cstdlib>
#include <pthread.h>
#include <unistd.h>

#include <stdio.h>
#include <iostream>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace ::apache::thrift::concurrency;
//using namespace std;
using std::vector;
using std::string;
using std::cout;
using std::cerr;
using std::endl;
using boost::shared_ptr;

class DHTNodeHandler : virtual public DHTNodeIf {
 private:
	NodeID current;
	NodeID successor;
	NodeID predecessor;
	vector<NodeID> ftable;
	int myport;
	pthread_mutex_t mylock;

 public:
  DHTNodeHandler(int port) {
	  pthread_mutex_init(&mylock, NULL);
	  initialize(port);
  }
  ~DHTNodeHandler() {
	  pthread_mutex_destroy(&mylock);
  }

  void findSucc(NodeID& _return, const std::string& key) {

	NodeID pred;
	findPred(pred, key);
	if (pred.id == current.id)
	{
		_return = successor;
	    _return.__set_count(pred.count);
		return;
	}
	shared_ptr<DHTNodeClient> client(connectClientAgency(pred.ip, pred.port));
	client->getNodeSucc(_return);
	_return.__set_count(pred.count);
  }

  void findPred(NodeID& _return, const std::string& key) {

    string left = current.id;
	string middle = key;
	string right = successor.id;
	/*
	bool flag;
    flag =  right > left ? (middle > left && middle <= right)
		: ((middle > left && middle > right) ||
				(middle < left && middle <= right));
	**/
	if (keyCompare(current.id, key, successor.id)) {
	    _return = current;
		_return.__set_count(0);
		return ;
	}

    for(int i = 255; i >= 0; i--) {
        if (ftable[i].id.empty()) continue;
        if (keyCompare(current.id, ftable[i].id, key)) {
			boost::shared_ptr<TSocket> socket(new TSocket(ftable[i].ip.c_str(),
						ftable[i].port));
			boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
			boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
			boost::shared_ptr<DHTNodeClient> client(new DHTNodeClient(protocol));
			transport->open();
			try {
				client->findPred(_return, key);
			} catch (...) {
				client = boost::shared_ptr<DHTNodeClient>();
				transport->close();
			}
			transport->close();
		   _return.__set_count(_return.count + 1);
			return ;
        }
	}
   assert(false);
  }

  void getNodeSucc(NodeID& _return) {
	  _return = successor;
  }

  void getNodePred(NodeID& _return) {
	  _return = predecessor;
  }

  void getFingertable(std::vector<NodeID> & _return) {
	  _return.assign(ftable.begin(), ftable.end());
  }

  void join(const NodeID& nodeId) {
	shared_ptr<DHTNodeClient> client(connectClientAgency(nodeId.ip, nodeId.port));

	//step 1 : find its successor using the joined Node
	predecessor.id.clear();
	client->findSucc(successor, current.id);
	 pthread_mutex_lock(&mylock);
	ftable[0] = successor;
	 pthread_mutex_unlock(&mylock);

	// step 2: notify its successor to update predessor to itself
	client = shared_ptr<DHTNodeClient>();
	client = connectClientAgency(successor.ip, successor.port);
	{
	  client->notify(current);
	}
  }

  void stabilize() {
   
	NodeID local_pred;
	shared_ptr<DHTNodeClient> client;
	
	// step 1 : get the predecessor of the successor
	if (successor.id != current.id) {
		client = connectClientAgency(successor.ip, successor.port);
		client->getNodePred(local_pred);
	} else {
		local_pred = predecessor;
	}
	if (local_pred.id == current.id)
		return;
    // step 2 : check wheather this predecessor is not set 
	if (local_pred.id.empty())
	{
		client = connectClientAgency(successor.ip, successor.port);
		client->notify(current);
		return;
	}
    // step 3 : check wheather this predecessor belongs to n, and n.successor
	if (keyCompare(current.id, local_pred.id, successor.id)) {
		// set the pred of successor as local_pred
		//client = connectClientAgency(successor.ip, successor.port);
		//client->notify(local_pred);
		// set the successor of the current node as local_pred
	    pthread_mutex_lock(&mylock);
		successor = local_pred;
		ftable[0] = successor;
	    pthread_mutex_unlock(&mylock);
		// notify the local_pred to set its predecessor as current node
		client = connectClientAgency(successor.ip, successor.port);
		client->notify(current);
	}
  }

  void notify(const NodeID& nodeId) {
		if (predecessor.id.empty() ||
				keyCompare(predecessor.id, nodeId.id, current.id)) {
	        pthread_mutex_lock(&mylock);
			predecessor = nodeId;
	        pthread_mutex_unlock(&mylock);
		}
  }

  /* from chord paper pseudo-code
   * i = random_index from 1 to finger[]
   * finger[i].node = find_successor(finger[i].start);
   *****/
  void fixFingers() {
		int randid = rand() % 256;
		NodeID succ, succl;
		if (successor.id == current.id)
			return;
		string start = addId(current.id, randid+1);
	//	string last = addId(current.id, 256);
		findSucc(succ, start);
	//	findSucc(succl, last);
	    pthread_mutex_lock(&mylock);
		ftable[randid] = succ; 
	//	ftable[255] = succ; 
	    pthread_mutex_unlock(&mylock);
  }

 private:
	void initialize(int port)
	{
		myport = port;
		current.__set_ip(get_eth_ip());
		current.__set_port(myport);
		current.__set_id(sha256_ip_port_hex(current.ip, current.port));
		NodeID noSet; // the finger table nodes are noSet at the start
        ftable.assign(256,noSet);
		predecessor = current;
		successor = current;
		ftable[0] = current;
	}
};


class AgrsStabilityThread
{
	public:
		shared_ptr<DHTNodeHandler> dht_handler;
		int inter_time;
};

void *stabilize_fix(void *thread_args)
{

    AgrsStabilityThread *argument = (AgrsStabilityThread *)thread_args;

    while(true) {
        argument->dht_handler->stabilize();
        argument->dht_handler->fixFingers();
        sleep(argument->inter_time);
    }
    return NULL;
}

void call_main(int port, int time) {
  shared_ptr<DHTNodeHandler> handler(new DHTNodeHandler(port));
  shared_ptr<TProcessor> processor(new DHTNodeProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
  AgrsStabilityThread argument;
  argument.dht_handler = handler;
  argument.inter_time = time;
  pthread_t stab_fix_thread;
  pthread_create(&stab_fix_thread, NULL, stabilize_fix, (void *)(&argument));

  //use threadedserver to support multple threads
  TThreadedServer server(processor,
                         serverTransport,
                         transportFactory,
                         protocolFactory);


  server.serve();
  return ;
}


