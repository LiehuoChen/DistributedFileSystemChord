// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "FileStore.h"
#include <protocol/TBinaryProtocol.h>
#include <server/TSimpleServer.h>
#include <transport/TServerSocket.h>
#include <transport/TBufferTransports.h>
#include <unordered_map>
#include <iostream>
#include <string>
#include <fstream>
#include "md5.h"


using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;


using boost::shared_ptr;
using std::unordered_map;
using std::cout;
using std::endl;
using std::string;
using std::ifstream;
using std::ofstream;

class FileStoreHandler : virtual public FileStoreIf {
 public:
  typedef unordered_map<string, RFileMetadata> FilenameToMetaMap;

  FileStoreHandler() :userFiles(), md5() {
    // Your initialization goes here
  }

  void listOwnedFiles(std::vector<RFileMetadata> & _return, const UserID& user) {
    // Your implementation goes here
    if (0 == userFiles.count(user) )  /*if no user, throw exception */
    {
        cout << "listOwnedFiles Failed!, no such user named " << user << endl;
        SystemException readExcep;
        readExcep.__set_message("listOwnedFiles Failed!, throw exception"
                "because of no such user");
        throw readExcep; 
    }
    FilenameToMetaMap &fMap = userFiles[user];
    _return.clear();
    for(auto it = fMap.begin(); it != fMap.end(); it++) {
       if (0 == it->second.deleted)
       {
             _return.push_back(it->second);
             cout << "List user name \"" << user << "\" : file name \"" << 
                 it->second.filename << "\"" << endl;
       } 
    }
   cout << "listOwnedFiles finished here for user \"" << user << "\"" << endl;
  }

  void writeFile(StatusReport& _return, const RFile& rFile) {
    // Your implementation goes here
    RFileMetadata fMeta = rFile.meta;
    char content_char[rFile.content.size()+1];
    string content = rFile.content;
    string user = rFile.meta.owner;
    string fileName = rFile.meta.filename;
    strcpy(content_char, rFile.content.c_str());

    if (0 == userFiles.count(user) )  /*if no user, create user */
    {
        userFiles[user] = FilenameToMetaMap();
    }


    FilenameToMetaMap &fMap = userFiles[user]; /*get the file list of user*/

    if (0 == fMap.count(fileName)) /*if new file, create it */
    {
        fMeta.created = (int64_t) time(0);
        fMeta.updated = (int64_t) time(0);
        fMeta.deleted = 0;
        fMeta.version = 0;
        
        fMeta.contentLength = rFile.content.size();
        fMeta.contentHash =string(md5.digestString(content_char));
        //cout << "the md5 number is " << md5.digestString(content_char) << endl; 
        fMap[fileName] = fMeta; 
    } else /*if old file, update it */
    {
       // cout << " I am here in old file created" << endl;
        fMap[fileName].version++;
        fMeta.updated = (int64_t) time(0);
        fMeta.deleted = 0; /* if old file, it should be in use again!*/
        fMeta.contentHash =string(md5.digestString(content_char));
        fMeta.contentLength = rFile.content.size();
        fMap[fileName] = fMeta;
    }
   
    int res = writeToDisk(fileName, user, rFile.content);
    _return.status = res ? Status::SUCCESSFUL : Status::FAILED;
    if (1 == res)
    {
        cout << "writeFile Success!, owner is " << user 
            << " filename is " << fileName << endl;
    } else
    {
        cout << "writeFile Fail,  owner is " << user 
            << " filename is " << fileName << endl;
    }
  }

  void readFile(RFile& _return, const std::string& filename, const UserID& owner) {
    // Your implementation goes here
    SystemException readExcep;
    if (0 == userFiles.count(owner))
    {
        readExcep.__set_message("readFile Failed! throw exception because of"
                " user not existed!");
        throw readExcep; 
    }

    FilenameToMetaMap &fMap = userFiles[owner];
    if (0 == fMap.count(filename))
    {
        readExcep.__set_message("readFile Failed! throw exception because of " 
                "filename not existed!");
        throw readExcep; 
    }
    _return.meta = fMap[filename];
    _return.__isset.meta = true;
    string fileName = owner + "_" + filename;
    //cout << "fileName is " << fileName << endl;
    ifstream readFile(fileName);
    if(NULL == readFile)
    {
        readExcep.__set_message("readFile Failed! file not existed on "
                "server");
        throw readExcep;
    }
    char *readBuf = new char[fMap[filename].contentLength];
    readFile.read(readBuf, fMap[filename].contentLength);
    readFile.close();
    cout << "read content " << readBuf << endl;
    _return.content = string(readBuf);
    _return.__isset.content = true;
    delete [] readBuf;
    cout << "readFile Success! owner is : " << owner << " filename is : " <<
        filename << endl;
  }

  void deleteFile(StatusReport& _return, const std::string& filename, const UserID& owner) {
    // Your implementation goes here
    SystemException deleteExcep;
    if (0 == userFiles.count(owner))
    {
        _return.status = Status::FAILED;
        printf("deleteFile Failed! user not existed! owner is %s, file name is %s",
                owner.c_str(), filename.c_str());
        deleteExcep.__set_message("deleteFile Failed!, throw exeception "
                " because of user not existed while deleting file");
        throw deleteExcep;
        //throw SystemException("user not existed while deleting file");
        //return;
    }
    
    FilenameToMetaMap &fMap = userFiles[owner]; /*get the file list of user*/
    if (0 == fMap.count(filename) || 0 != fMap[filename].deleted)
    {
        _return.status = Status::FAILED;
        cout << "deleteFile Failed!, file not existed or deleted!, owner is "
            << owner << " file name is " << filename;
        deleteExcep.__set_message("deleteFile Failed, throw exception because"
                " of file not existed or deleted while deleting");
        throw deleteExcep;
        //throw SystemException("file not existed or deleted while deleting file");
        //return;
    }
    string fileName = owner + "_" + filename; 
    unlink(fileName.c_str());
    fMap[filename].deleted = (int64_t) time(0);
    _return.status = Status::SUCCESSFUL;
    cout << "deleteFile Success!, owner is "
         << owner << " file name is " << filename << endl;
    return;
  }

 private:
  unordered_map<UserID, FilenameToMetaMap> userFiles;
  MD5 md5;
  int writeToDisk(const string& filename, const string& owner,
      const string &content)
    {
        string fileName =  owner + "_" + filename;
        ofstream writeFile(fileName);
        if (NULL == writeFile) 
            return -1;
        writeFile.write(content.c_str(), content.size());
        writeFile.close();    
        return 1;
    }

};

int main(int argc, char **argv) {
  int port = 9090;
  if (1 == argc)
      port = 9090;
  else 
      port = atoi(argv[1]);
  shared_ptr<FileStoreHandler> handler(new FileStoreHandler());
  shared_ptr<TProcessor> processor(new FileStoreProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

