// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "FileStore.h"
#include "chord_dht_types.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <transport/TSocket.h>
#include <transport/TBufferTransports.h>
#include <protocol/TBinaryProtocol.h>
#include <iostream>
#include <string>
#include <unordered_map>
#include <fstream>
#include "sha256.h"


using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;
using std::string;
using std::cout;
using std::endl;
using std::unordered_map;
using std::ifstream;
using std::ofstream;

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/ioctl.h>
#include <net/if.h>
#include <arpa/inet.h>
#include <ifaddrs.h>

int global_port = 9090;

string get_eth_ip(void)
{
	struct ifaddrs *addrs, *tmp;
	getifaddrs(&addrs);
	tmp = addrs;
	char host[NI_MAXHOST];

	while (tmp) {
		if (tmp->ifa_addr 
				&& !strncmp(tmp->ifa_name, "eth", 3)  
				&& tmp->ifa_addr->sa_family == AF_INET)
			getnameinfo(tmp->ifa_addr, sizeof(struct sockaddr_in),
					host, NI_MAXHOST, NULL, 0, NI_NUMERICHOST);
		tmp = tmp->ifa_next;
	}

	freeifaddrs(addrs);
	return host;
}

bool keyCompare(const std::string &left,
						 const std::string &middle,
						 const std::string &right)
{
	return right > left ? (middle > left && middle < right)
		: ((middle > left && middle > right) ||
				(middle < left && middle < right));
}


class FileStoreHandler : virtual public FileStoreIf {
 public:
  typedef unordered_map<string, RFile> FilenameToMetaMap;
  FileStoreHandler() :userFiles(), ftable_inited(false), has_predesor(false) {}

  void writeFile(const RFile& rFile) {
    SystemException exception;
	RFile lrfile;
	lrfile.__set_content(rFile.content);
    if (!checkRoute(rFile.meta.owner, rFile.meta.filename)) {
        exception.__set_message("file not belong to my range");
        throw exception;
    }
    RFileMetadata fMeta = rFile.meta;
    char content_char[rFile.content.size()+1];
    string content = rFile.content;
    string user = rFile.meta.owner;
    string fileName = rFile.meta.filename;
    strcpy(content_char, rFile.content.c_str());

    if (!userFiles.count(user) )  /*if no user, create user */
        userFiles[user] = FilenameToMetaMap();

    FilenameToMetaMap &fMap = userFiles[user]; /*get the file list of user*/
	if (!fMap.count(fileName)) /*if new file, create it */
    {
        fMeta.__set_created((int64_t) time(0));
        fMeta.__set_updated((int64_t) time(0));
        fMeta.__set_deleted(0);
        fMeta.__set_version(0);
        
        fMeta.__set_contentLength(rFile.content.size());
        fMeta.__set_contentHash(sha256_calc_hex(content_char));
		lrfile.__set_meta(fMeta);
        fMap[fileName] = lrfile;
    } else {
		fMeta.version++;
        fMeta.__set_updated((int64_t) time(0));
        fMeta.__set_deleted(0);
        fMeta.__set_contentHash(sha256_calc_hex(content_char));
        fMeta.__set_contentLength(rFile.content.size());
		lrfile.__set_meta(fMeta);
        fMap[fileName] = lrfile;

    }
    cout << "writeFile success\n";
  }

  void readFile(RFile& _return, const std::string& filename, const UserID& owner) {
    SystemException readExcep;
	RFile lrfile;
    cout << "readFile: \n";
    if (!checkRoute(owner, filename)) {
       readExcep.__set_message("file not belong to my range");
        throw readExcep;
    }

    if (!userFiles.count(owner)) {
        readExcep.__set_message("readFile Failed! throw exception because of"
                " user not existed!");
        throw readExcep; 
    }

    FilenameToMetaMap &fMap = userFiles[owner];
	if (!fMap.count(filename) || fMap[filename].meta.deleted) {
        cout << "File not existed or deleted!, owner is "
            << owner << " file name is " << filename;
        readExcep.__set_message("deleteFile Failed, throw exception because"
                " of file not existed or deleted while deleting");
        throw readExcep;
    }

    if (!fMap.count(filename)) {
        readExcep.__set_message("readFile Failed! throw exception because of " 
                "filename not existed!");
        throw readExcep; 
    }
	_return.__set_meta(fMap[filename].meta);
	_return.__set_content(fMap[filename].content);
    cout << "readFile success\n";
  }

  void deleteFile(const std::string& filename, const UserID& owner) {
    // Your implementation goes here
    SystemException deleteExcep;
    cout << "deleteFile: \n";
    if (!checkRoute(owner, filename)) {
        deleteExcep.__set_message("file not belong to my range");
        throw deleteExcep;
    }

    if (!userFiles.count(owner))
    {
        printf("deleteFile Failed! user not existed! owner is %s, file name is %s",
                owner.c_str(), filename.c_str());
        deleteExcep.__set_message("deleteFile Failed!, throw exeception "
                " because of user not existed while deleting file");
        throw deleteExcep;
    }
    
    FilenameToMetaMap &fMap = userFiles[owner]; /*get the file list of user*/
    if (!fMap.count(filename) || fMap[filename].meta.deleted)
    {
        cout << "deleteFile Failed!, file not existed or deleted!, owner is "
            << owner << " file name is " << filename;
        deleteExcep.__set_message("deleteFile Failed, throw exception because"
                " of file not existed or deleted while deleting");
        throw deleteExcep;
    }
    fMap[filename].meta.__set_deleted((int64_t) time(0));
    cout << "deleteFile success\n";
    return;
  }

  void setFingertable(const std::vector<NodeID> & node_list) {
    // Your implementation goes here
    cout << "setFingertable\n";
    dhtSetFingertable(node_list);
  }

  void findSucc(NodeID& _return, const std::string& key) {
    // Your implementation goes here
    cout << "findSucc key: " <<  key.c_str() << endl;
    if (!ftable_inited) {
        cout << "fingertable not be initialized, run the init first\n";
        SystemException exception;
        exception.__set_message("fingertable not be initialized yet, "
                "run the init project first");
        throw exception;
    }

    NodeID pred = dhtFindPred(key);
	if (pred.id == current.id) {
		_return = successor;
		return;
	}
	boost::shared_ptr<FileStoreClient> client(getClientConn(pred.ip, pred.port));
	if (!client.get()) {
		SystemException exception;
		char errmsg[64];
		snprintf(errmsg, 64, "connect error at [%s: %d]", 
				pred.ip.c_str(), pred.port);
		cout << errmsg << endl;
		exception.__set_message(errmsg);
		throw exception;
	}
	NodeID result;
	client->getNodeSucc(result);
	_return = result;
    return;
  }

  void findPred(NodeID& _return, const std::string& key) {
    // Your implementation goes here
    cout << "findPred\n";
    if (!ftable_inited) {
        cout << "fingertable not be initialized, run the init first\n";
        SystemException exception;
        exception.__set_message("fingertable not be initialized yet, "
                "run the init project first");
        throw exception;
    }
    _return = dhtFindPred(key);
  }

  void getNodeSucc(NodeID& _return) {
    // Your implementation goes here
    if (!ftable_inited) {
        cout << "fingertable not be initialized, run the init first\n";
        SystemException exception;
        exception.__set_message("fingertable not be initialized yet, "
                "run the init project first");
        throw exception;
    }
    _return = successor;
    cout << "getNodeSucc\n";
  }

 private:
  unordered_map<UserID, FilenameToMetaMap> userFiles;
	NodeID current;
	NodeID successor;
	NodeID predessor;
	NodeID ftable[256];
	bool ftable_inited;
	bool has_predesor;

	boost::shared_ptr<FileStoreClient> getClientConn(const std::string &ip, int port) const
	{
		boost::shared_ptr<TSocket> socket(new TSocket(ip.c_str(), port));
		boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
		boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
		boost::shared_ptr<FileStoreClient> client(new FileStoreClient(protocol));

		try {
			transport->open();
		} catch (...) {
			cout << "Conect to Node [" << ip << " : " << port << "] Failed ! "
				<< endl;
			client = boost::shared_ptr<FileStoreClient>();
		}
		return client;
	}

	bool checkRoute(const std::string &owner, const std::string &filename) 
	{
		if (!ftable_inited)
			return false;

		std::string key = sha256_filename_owner_hex(owner, filename);
		if (key == current.id)
			return true;
		if (!has_predesor) {
			predessor = dhtFindPred(current.id);
			has_predesor = true;
		}

		return keyCompare(predessor.id, key, current.id);
	}

	void dhtSetFingertable(const std::vector<NodeID> &node_list)
	{
		current.__set_ip(get_eth_ip());
		current.__set_port(global_port);
		current.__set_id(sha256_ip_port_hex(current.ip, current.port));
		for(int i = 0; i < (signed)node_list.size(); i++) {
			ftable[i] = node_list[i];
		}
		ftable_inited = true;
		successor = ftable[0];
	}

	NodeID dhtFindPred(const std::string &key) const
	{
		if (keyCompare(current.id, key, successor.id)) {
			cout << " I am here before return current ip and port is " <<
				current.ip << " : " << current.port << " current id : " <<
				current.id << " successor.id : " << successor.id << endl;
			return current;
		}

		for(int i = 255; i >= 0; i--) {
			if (keyCompare(current.id, ftable[i].id, key)) {
				boost::shared_ptr<FileStoreClient> client(getClientConn(ftable[i].ip, ftable[i].port));
				if (!client.get()) {
					SystemException exception;
					char errmsg[64];
					snprintf(errmsg, 64, "connect error at [%s: %d]", ftable[i].ip.c_str(), ftable[i].port);
					exception.__set_message(errmsg);
					throw exception;
				} 

				NodeID rst;
				client->findPred(rst, key);
				return rst;
			}
		}
		return current;
	}
};

int main(int argc, char **argv) {
  int port = 3030;
  if (argc > 1)
      port = atoi(argv[1]);

  global_port = port;
  shared_ptr<FileStoreHandler> handler(new FileStoreHandler());
  shared_ptr<TProcessor> processor(new FileStoreProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

